<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/d3@6"></script>
</head>
<style>
    body {
        background-color:white;
    }
</style>
<body>
    
</body>
<script async>


graph = fetch('./upsTree2.json')
    .then((response) => response.json())
    .then((json) =>  {
       let {nodes,links} = json
       //nodes and links need ids, nodes should have them but, links don't, so we create them

     links.forEach((link,i) => {link.id = Math.random()})//could also just be i
  return {
    'graph':ForceGraph({nodes,links}, {
      nodeId: d => d.id,
      nodeGroup: d => 0,//Could be used for coloring nodes, now there all the same, d => d.group,
      nodeTitle: d => `${d.id}`,
      nodeStroke:"#000",
      nodeStrokeWidth:0,
      nodeRadius:20,
      width:1400,
      height: 1000,
      invalidation: undefined// a promise to stop the simulation when the cell is re-run
    }),
      'nodes':json.nodes,
      'links':json.links
    }
  });

graph.then(g =>{
  //draws graph on the screen
  document.body.appendChild(g.graph)

  //SWAPS ALL GRAPH DATA
  // newData = fetch('./upsTree2.json')
  //   .then((response) => response.json())
  //   .then((json) =>  {
  //       // g.nodes = json.nodes
  //       // g.links = json.links

  //     setInterval( () => {

  //       g.nodes = json.nodes
  //       g.links = json.links
  //       // g.nodes.pop()

  //        g.graph.update(g.nodes,g.links)
  //     },3000)
  
  //   })
  setTimeout(() => {
    g.nodes.push({'id':'msft'})
    g.links.push({'source':'msft','target':'ups','value':0.8,'id':Math.random()})
    g.graph.update(g.nodes,g.links)
    setInterval(() => {
      g.nodes.pop()
      g.graph.update(g.nodes,g.links)
    },2000)
  },2000)

  

});

// Copyright 2021 Observable, Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/disjoint-force-directed-graph
function ForceGraph({
  nodes, // an iterable of node objects (typically [{id}, …])
  links // an iterable of link objects (typically [{source, target,value}, …])
}, {
  graphName = "", //used with the ids only matters when multiple of the graph are used
  nodeId = d => d.id, // given d in nodes, returns a unique identifier (string)
  nodeGroup, // given d in nodes, returns an (ordinal) value for color
  nodeGroups, // an array of ordinal values representing the node groups
  nodeTitle, // given d in nodes, a title string
  titleColor = "white",
  nodeFill = "currentColor", // node stroke fill (if not using a group color encoding)
  nodeStroke = "#fff", // node stroke color
  nodeStrokeWidth = 1.5, // node stroke width, in pixels
  nodeStrokeOpacity = 1, // node stroke opacity
  nodeRadius = 5, // node radius, in pixels
  linkSource = ({source}) => source, // given d in links, returns a node identifier string
  linkTarget = ({target}) => target, // given d in links, returns a node identifier string
  linkValue = ({value}) => value,
  linkStroke = "#999", // link stroke color
  linkStrokeOpacity = 0.6, // link stroke opacity
  linkStrokeWidth = 1.5, // given d in links, returns a stroke width in pixels
  linkStrokeLinecap = "round", // link stroke linecap
  linkDistance = d => 75 * (1 -d.value) + 25,
  width = 640, // outer width, in pixels
  height = 400, // outer height, in pixels
  invalidation // when this promise resolves, stop the simulation
} = {}) {


  const T = nodeTitle == null ? null : d3.map(nodes, nodeTitle);


  
  //svg wrapper
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [-width / 2, -height / 2, width, height])
      .attr("style", "max-width: 100%; height: auto; height: intrinsic;");



  
  const nodeWrapper = svg.append("g")
      .attr("fill", nodeFill)
      .attr("stroke", nodeStroke)
      .attr("stroke-opacity", nodeStrokeOpacity)
      .attr("stroke-width", nodeStrokeWidth)

  //node and link singular are the d3 data object that controls the dom elements, links and nodes are the data points that node and link use
  let node;
  let link;
  let simulation;
  let prevNodes;
  let prevLinks;
    update = (nodes,links) => {

      

      const N = d3.map(nodes, nodeId)

      //Kind of a slow implementation, TODO remove links that are related to a node that got dropped

      links = links.filter((link) => N.includes(link.source) && N.includes(link.target) || N.includes(link.source.id) && N.includes(link.target.id))
  

        //create link force to drive simulation
        const forceLink = d3.forceLink(links).id(({index: i}) => N[i]).distance(linkDistance)
      if(simulation) {
           simulation.nodes(nodes).force("link",forceLink) 
         } 
         else {
          simulation = d3.forceSimulation(nodes)
            .force("charge", d3.forceManyBody().strength(-300))
            .force("link",forceLink)
            .force("x", d3.forceX())
            .force("y", d3.forceY())
            .force("collision",d3.forceCollide([3+nodeRadius]))
            .on("tick", ticked);
         }
      //changes node html elements
      node = nodeWrapper.selectAll("g")
        .data(nodes, node => node.id)
        .join(
        enter => enter
        .append("g") //appends group to be moved around
        // .append('text').text(d => d.id)
        .append("image") //appends and styles image of company logo
        .attr("mask","url(#icon-mask)")
        .attr("xlink:href",(d) => `./ticker_icons/${d.id.toLocaleLowerCase()}.png`)
        .attr("x",-nodeRadius).attr("y",-nodeRadius)
        .attr("height",2*nodeRadius)
        .attr("width",2*nodeRadius) 
        .select(function(){
          return this.parentNode; //makes sure node returns to the g tag, not the image tag so the image is what gets moved
        }),
        update => update.attr('fill','red'),
        exit => exit.remove()
        ).attr("id",(d,i) => graphName + "group" + i)
        .call(drag(simulation))

        //changes link html elements
        link = linkWrapper.selectAll("line")
            .data(links,link => link.id)
            .join("line");
         //updates what nodes and links are in the sim

        //If sim isn't defined, create it and all forces, if it is just change the nodes and links as that's what is being updated
        function ticked() {
          
            link
              .attr("x1", d => d.source.x)
              .attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x)
              .attr("y2", d => d.target.y);


            node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
      }
    }


  const linkWrapper = svg.append("g")
    .attr("stroke", linkStroke)
    .attr("stroke-opacity", linkStrokeOpacity)
    .attr("stroke-width", typeof linkStrokeWidth !== "function" ? linkStrokeWidth : null)
    .attr("stroke-linecap", linkStrokeLinecap)




    //draws given inital nodes and links
    update(nodes,links)
    
      


 

  //This line appends circles to the chart
  //node.append("circle").attr("r", nodeRadius).attr("id",(d,i) => graphName + "circle" + i).attr("fill",(d,i) => `url(#${graphName}pattern${i})`)
  //This line appends circular images to the chart
    // node.append("text").text(d => d.id)


  svg.append("defs").append("mask").attr("id","icon-mask").append("circle").attr("r",1.25*nodeRadius).attr("fill","white")
  
  // Handle invalidation.
  if (invalidation != null) invalidation.then(() => 
  {
    console.log("stopping sim")
    simulation.stop()});



  function drag(simulation) {    
    function dragstarted(event) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }
    
    function dragged(event) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }
    
    function dragended(event) {
      if (!event.active) simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }
    
    return d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended);
  } 

  return Object.assign(svg.node(),{update:update});

}
</script>
</html>